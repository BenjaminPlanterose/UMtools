{
df = data.frame(x = m, y = u)
df_norm = df/data.frame(x = rep(max(df$x), nrow(df)), y = rep(max(df$y), nrow(df)))
df_norm$label = class_i
coefA = aggregate(. ~ label, df_norm[c("x", "label")], mean)$x
coefB = aggregate(. ~ label, df_norm[c("y", "label")], mean)$y
pos1 = which.min((coefA + coefB)/2); coefA[pos1] = NA; coefB[pos1] = NA;
pos4 = which.min(abs(coefA - coefB)); coefA[pos4] = NA; coefB[pos4] = NA;
pos2 = which.max(coefB); pos3 = which.max(coefA)
real_order <- c(pos1, pos2, pos3, pos4)
class_i <- factor(class_i, levels = c(1,2,3,4))
levels(class_i) <- as.character(match(1:4, real_order))
col_vec <- as.vector(class_i); out = col_vec
col_vec[col_vec == '1'] <- alpha('black', 0.5)
col_vec[col_vec == '2'] <- alpha('dodgerblue3', 0.5)
col_vec[col_vec == '3'] <- alpha('brown3', 0.5)
col_vec[col_vec == '4'] <- alpha('darkmagenta', 0.5)
out[out == '1'] <- "blue"; out[out == '2'] <- "purple"; out[out == '3'] <- "red"; out[out == '4'] <- "red"
plot(df$x, df$y, col = col_vec, pch = 19, main = CpG, xlab = 'M', ylab = 'U',
xlim = c(0, max(df$x) + 100), ylim = c(0, max(df$y) + 100))
return(out)
}
}
Kcall_CpG("cg15771735", M_U$M, M_U$U, minPts = 5, eps = 0.1)
#' Transforms number of beads matrix from G/R to U/M
#' @description a
#' @details a
#' @param nBeads A matrix containing the number of beads per probe and per sample (probes as rows, samples as columns)
#' @param rgSet An rgSet object imported by minfi (see minfi::read.metharray.exp for details)
#' @return A matrix containing number of beads per CpG and per sample, \code{nBeads_cg}, (CpGs as rows, samples as columns)
#' @examples
#' beads_GR_to_UM(nBeads, rgSet)
Kcall_CpG <- function(CpG, M, U, plot = T, minPts = 12, eps = 0.035)
{
m = M[CpG,]; u = U[CpG,]
df = data.frame(x = (m + 0)/(u + m + 100), y = log2(u + m + 100))
df$y = (df$y - min(df$y))/(max(df$y)) # Switch
res = dbscan::dbscan(df, eps, minPts)$cluster
if(plot)
{
K = length(table(res[res != 0]))
if(K > 8)
{
stop("cannot plot; more clusters than colours")
}
pal = brewer.pal(8, "Dark2")[1:K]
col = as.factor(res)
if(sum(col == "0") > 0)
{
levels(col) = c("black", pal)
}
else
{
levels(col) = pal
}
plot(m, u, col = as.character(col), pch = 19, main = CpG)
}
nclust = length(table(res[res != 0]))
return(nclust)
}
Kcall_CpG("cg15771735", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg03398919", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg00814218", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.04)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.05)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.06)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.07)
Kcall_CpG("cg15771735", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg03398919", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg00814218", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.07)
Kcall_CpG("cg15771735", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg03398919", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg00814218", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.1)
chrY = rownames(annotation)[annotation$chr == "chrY"]
K_vec = par_EW_Kcalling(M_U$M[chrY,], M_U$U[chrY,], minPts = 5, eps = 0.1)
#' Computes bimodality per CpG across samples in a coefficient of variation matrix
#' @description a
#' @details a
#' @param CV A coefficient of variation matrix (probes as rows, samples as columns)
#' @return A vector of coefficient of bimodality per CpG, \code{BC}
#' @examples
#' compute_BC_CV(CV)
par_EW_Kcalling <- function(M, U, minPts = 12, eps = 0.035)
{
k_per_CpG <- function(df, minPts = 12, eps = 0.035)
{
m = df$x; u = df$y
df = data.frame(x = m/(u + m + 100), y = log2(u + m + 100))
df$y = (df$y - min(df$y))/(max(df$y)) # Switch
res = dbscan::dbscan(df, eps, minPts)$cluster
nclust = length(table(res[res != 0]))
return(nclust)
}
np <- detectCores(logical = FALSE)
cl <- makeCluster(np)
clusterExport(cl, c("k_per_CpG", "dbscan", "eps", "minPts"), envir=environment())
print(dim(M)); print(dim(U))
r <- parSapply(cl = cl, X = 1:nrow(M), FUN = function(X) k_per_CpG(data.frame(x = M[X,], y = U[X,]),
minPts, eps)) # process per row
names(r) <- rownames(M)
stopCluster(cl)
return(r)
}
K_vec = par_EW_Kcalling(M_U$M[chrY,], M_U$U[chrY,], minPts = 5, eps = 0.1)
#' Computes bimodality per CpG across samples in a coefficient of variation matrix
#' @description a
#' @details a
#' @param CV A coefficient of variation matrix (probes as rows, samples as columns)
#' @return A vector of coefficient of bimodality per CpG, \code{BC}
#' @examples
#' compute_BC_CV(CV)
par_EW_Kcalling <- function(M, U, minPts = 12, eps = 0.035)
{
k_per_CpG <- function(df, minPts = 12, eps = 0.035)
{
m = df$x; u = df$y
df = data.frame(x = m/(u + m + 100), y = log2(u + m + 100))
df$y = (df$y - min(df$y))/(max(df$y)) # Switch
res = dbscan::dbscan(df, eps, minPts)$cluster
nclust = length(table(res[res != 0]))
return(nclust)
}
print(dim(M))
np <- detectCores(logical = FALSE)
cl <- makeCluster(np)
clusterExport(cl, c("k_per_CpG", "dbscan", "eps", "minPts"), envir=environment())
r <- parSapply(cl = cl, X = 1:nrow(M), FUN = function(X) k_per_CpG(data.frame(x = M[X,], y = U[X,]),
minPts, eps)) # process per row
names(r) <- rownames(M)
stopCluster(cl)
return(r)
}
K_vec = par_EW_Kcalling(M_U$M[chrY,], M_U$U[chrY,], minPts = 5, eps = 0.1)
table(K_vec)
#' Computes bimodality per CpG across samples in a coefficient of variation matrix
#' @description a
#' @details a
#' @param CV A coefficient of variation matrix (probes as rows, samples as columns)
#' @return A vector of coefficient of bimodality per CpG, \code{BC}
#' @examples
#' compute_BC_CV(CV)
par_EW_Kcalling <- function(M, U, minPts = 12, eps = 0.035)
{
k_per_CpG <- function(df, minPts = 12, eps = 0.035)
{
m = df$x; u = df$y
df = data.frame(x = m/(u + m + 100), y = log2(u + m + 100))
df$y = (df$y - min(df$y))/(max(df$y)) # Switch
res = dbscan::dbscan(df, eps, minPts)$cluster
nclust = length(table(res[res != 0]))
return(nclust)
}
print(dim(M)); print(dim(U))
np <- detectCores(logical = FALSE)
cl <- makeCluster(np)
clusterExport(cl, c("k_per_CpG", "dbscan", "eps", "minPts"), envir=environment())
r <- parSapply(cl = cl, X = 1:nrow(M), FUN = function(X) k_per_CpG(data.frame(x = M[X,], y = U[X,]),
minPts, eps)) # process per row
names(r) <- rownames(M)
stopCluster(cl)
return(r)
}
K_vec = par_EW_Kcalling(M_U$M[chrY,], M_U$U[chrY,], minPts = 5, eps = 0.1)
warnings()
K_vec = par_EW_Kcalling(M_U$M[chrY,], M_U$U[chrY,], minPts = 5, eps = 0.1)
table(K_vec)
Kcall_CpG("cg15771735", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg03398919", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg00814218", M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG("cg27024127", M_U$M, M_U$U, minPts = 5, eps = 0.1)
names(which(K_vec == 1))[2] # "cg02494853"
UM_plot(M = M_U$M, U = M_U$U, CpG = "cg02494853", sex = pheno$sex)
annotation["cg02494853", c("chr", "pos")] # chrY   4868397
# K = 1 are cross-reactive
UM_plot(M = M_U$M, U = M_U$U, CpG = "cg02494853", sex = pheno$sex)
annotation["cg02494853", c("chr", "pos")] # chrY   4868397
setwd("/home/ben/Documents/Git/UMtools/data/")
load("training_set.Rdata")
# data("training_set") # This should work
training_set
#' Transforms number of beads matrix from G/R to U/M
#' @description a
#' @details a
#' @param nBeads A matrix containing the number of beads per probe and per sample (probes as rows, samples as columns)
#' @param rgSet An rgSet object imported by minfi (see minfi::read.metharray.exp for details)
#' @return A matrix containing number of beads per CpG and per sample, \code{nBeads_cg}, (CpGs as rows, samples as columns)
#' @examples
#' beads_GR_to_UM(nBeads, rgSet)
#'
train_k_caller <- function(M, U, training_set, minPts, eps)
{
k1_res = par_EW_Kcalling(M[training_set$k_1,], U[training_set$k_1,], minPts, eps)
k2_res = par_EW_Kcalling(M[training_set$k_2,], U[training_set$k_2,], minPts, eps)
k3_res = par_EW_Kcalling(M[training_set$k_3,], U[training_set$k_3,], minPts, eps)
k4_res = par_EW_Kcalling(M[training_set$k_4,], U[training_set$k_4,], minPts, eps)
pred = c(k1_res, k2_res, k3_res, k4_res)
real = c(rep(1, length(k_1)), rep(2, length(k_2)),
rep(3, length(k_3)), rep(4, length(k_4)))
cm = table(real, pred)
perfor1_3 = evaluate_multiclass(cm[1:3, 1:3])
perfor1_4 = evaluate_multiclass(cm[1:4, 1:4])
return(list(confusion_matrix = cm, performance_one_to_three_clusters = perfor1_3, performance_one_to_four_clusters = perfor1_4))
}
training_set
train_k_caller(M_U$M, M_U$U, training_set, 5, 0.1)
#' Transforms number of beads matrix from G/R to U/M
#' @description a
#' @details a
#' @param nBeads A matrix containing the number of beads per probe and per sample (probes as rows, samples as columns)
#' @param rgSet An rgSet object imported by minfi (see minfi::read.metharray.exp for details)
#' @return A matrix containing number of beads per CpG and per sample, \code{nBeads_cg}, (CpGs as rows, samples as columns)
#' @examples
#' beads_GR_to_UM(nBeads, rgSet)
#'
train_k_caller <- function(M, U, training_set, minPts, eps)
{
evaluate_multiclass <- function(cm) # Obtained from the following post: https://blog.revolutionanalytics.com/2016/03/com_class_eval_metrics_r.html
{
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted
accuracy = sum(diag) / n
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
macroPrecision = mean(precision)
macroRecall = mean(recall)
macroF1 = mean(f1)
message(paste("macroPrecision =", macroPrecision))
message(paste("macroRecall =", macroRecall))
message(paste("macroF1 =", macroF1))
}
k1_res = par_EW_Kcalling(M[training_set$k_1,], U[training_set$k_1,], minPts, eps)
k2_res = par_EW_Kcalling(M[training_set$k_2,], U[training_set$k_2,], minPts, eps)
k3_res = par_EW_Kcalling(M[training_set$k_3,], U[training_set$k_3,], minPts, eps)
k4_res = par_EW_Kcalling(M[training_set$k_4,], U[training_set$k_4,], minPts, eps)
pred = c(k1_res, k2_res, k3_res, k4_res)
real = c(rep(1, length(k_1)), rep(2, length(k_2)),
rep(3, length(k_3)), rep(4, length(k_4)))
cm = table(real, pred)
perfor1_3 = evaluate_multiclass(cm[1:3, 1:3])
perfor1_4 = evaluate_multiclass(cm[1:4, 1:4])
return(list(confusion_matrix = cm, performance_one_to_three_clusters = perfor1_3, performance_one_to_four_clusters = perfor1_4))
}
performance = train_k_caller(M_U$M, M_U$U, training_set, 5, 0.1)
performance
#' Transforms number of beads matrix from G/R to U/M
#' @description a
#' @details a
#' @param nBeads A matrix containing the number of beads per probe and per sample (probes as rows, samples as columns)
#' @param rgSet An rgSet object imported by minfi (see minfi::read.metharray.exp for details)
#' @return A matrix containing number of beads per CpG and per sample, \code{nBeads_cg}, (CpGs as rows, samples as columns)
#' @examples
#' beads_GR_to_UM(nBeads, rgSet)
#'
train_k_caller <- function(M, U, training_set, minPts, eps)
{
evaluate_multiclass <- function(cm) # Obtained from the following post: https://blog.revolutionanalytics.com/2016/03/com_class_eval_metrics_r.html
{
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted
accuracy = sum(diag) / n
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
macroPrecision = mean(precision)
macroRecall = mean(recall)
macroF1 = mean(f1)
message(paste("macroPrecision =", macroPrecision))
message(paste("macroRecall =", macroRecall))
message(paste("macroF1 =", macroF1))
}
k1_res = par_EW_Kcalling(M[training_set$k_1,], U[training_set$k_1,], minPts, eps)
k2_res = par_EW_Kcalling(M[training_set$k_2,], U[training_set$k_2,], minPts, eps)
k3_res = par_EW_Kcalling(M[training_set$k_3,], U[training_set$k_3,], minPts, eps)
k4_res = par_EW_Kcalling(M[training_set$k_4,], U[training_set$k_4,], minPts, eps)
pred = c(k1_res, k2_res, k3_res, k4_res)
real = c(rep(1, length(k_1)), rep(2, length(k_2)),
rep(3, length(k_3)), rep(4, length(k_4)))
cm = table(real, pred)
perfor1_3 = evaluate_multiclass(cm[1:3, 1:3])
perfor1_4 = evaluate_multiclass(cm[1:4, 1:4])
return(list(confusion_matrix = cm))
}
train_k_caller(M_U$M, M_U$U, training_set, 5, 0.07)
#' Transforms number of beads matrix from G/R to U/M
#' @description a
#' @details a
#' @param nBeads A matrix containing the number of beads per probe and per sample (probes as rows, samples as columns)
#' @param rgSet An rgSet object imported by minfi (see minfi::read.metharray.exp for details)
#' @return A matrix containing number of beads per CpG and per sample, \code{nBeads_cg}, (CpGs as rows, samples as columns)
#' @examples
#' beads_GR_to_UM(nBeads, rgSet)
#'
train_k_caller <- function(M, U, training_set, minPts, eps)
{
evaluate_multiclass <- function(cm) # Obtained from the following post: https://blog.revolutionanalytics.com/2016/03/com_class_eval_metrics_r.html
{
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted
accuracy = sum(diag) / n
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
macroPrecision = mean(precision)
macroRecall = mean(recall)
macroF1 = mean(f1)
return(c(macroPrecision = macroPrecision, macroRecall = macroRecall, macroF1 = macroF1))
}
k1_res = par_EW_Kcalling(M[training_set$k_1,], U[training_set$k_1,], minPts, eps)
k2_res = par_EW_Kcalling(M[training_set$k_2,], U[training_set$k_2,], minPts, eps)
k3_res = par_EW_Kcalling(M[training_set$k_3,], U[training_set$k_3,], minPts, eps)
k4_res = par_EW_Kcalling(M[training_set$k_4,], U[training_set$k_4,], minPts, eps)
pred = c(k1_res, k2_res, k3_res, k4_res)
real = c(rep(1, length(k_1)), rep(2, length(k_2)),
rep(3, length(k_3)), rep(4, length(k_4)))
cm = table(real, pred)
perfor1_3 = evaluate_multiclass(cm[1:3, 1:3])
perfor1_4 = evaluate_multiclass(cm[1:4, 1:4])
return(list(confusion_matrix = cm, performance_one_to_three_clusters = perfor1_3, performance_one_to_four_clusters = perfor1_4))
}
train_k_caller(M_U$M, M_U$U, training_set, 4, 0.07)
train_k_caller(M_U$M, M_U$U, training_set, 3, 0.07)
train_k_caller(M_U$M, M_U$U, training_set, 3, 0.05)
sample(training_set$k_1, 1)
sample(training_set$k_1, 1)
Kcall_CpG(sample(training_set$k_1, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
# Training annotated with dataset of 426 EUR MZ twin pairs. Training set may not be correctly annotated
# for other ancestries and other sample sizes.
Kcall_CpG(sample(training_set$k_1, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_2, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_3, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
Kcall_CpG(sample(training_set$k_4, 1), M_U$M, M_U$U, minPts = 5, eps = 0.1)
#' Computes bimodality per CpG across samples in a coefficient of variation matrix
#' @description a
#' @details a
#' @param CV A coefficient of variation matrix (probes as rows, samples as columns)
#' @return A vector of coefficient of bimodality per CpG, \code{BC}
#' @examples
#' compute_BC_CV(CV)
Visualize_cometh = function(annotation, CpG, distance, L_bound, R_bound, beta_mat, probe2exclude = NULL, max_y = 11)
{
# CpG = 'cg01026744'
# R_bound = 4; L_bound = 4
# distance = 50
annotation = annotation[order(annotation$chr, annotation$pos),]
sub_annot = annotation[CpG,]
tmp = annotation[annotation$chr == sub_annot$chr,]
tmp = tmp[(tmp$pos > sub_annot$pos - distance) & (tmp$pos < sub_annot$pos + distance),]
if(nrow(tmp) == 1)
{
stop('Increase distance to make plot. No other CpG could be found in the proposed window')
}
pos_vec = match(rownames(tmp), rownames(annotation))
if(pos_vec[1] - L_bound <= 0)
{
stop('Shorten L_bound; There are not so many CpGs on the left')
}
if(annotation[pos_vec[length(pos_vec)],'chr'] != annotation[pos_vec[length(pos_vec)] + R_bound,'chr'])
{
stop('Shorten R_bound; You are already on the next chromosome')
}
sub_annot = annotation[(pos_vec[1]-L_bound):(pos_vec[length(pos_vec)] + R_bound),]
#beta_mat = M[rownames(sub_annot),]/(M[rownames(sub_annot),]+U[rownames(sub_annot),]+100)
beta_mat = beta_mat[rownames(sub_annot),]
# beta_mat = Beta[rownames(sub_annot),]
dat = as.matrix(cor(t(beta_mat)))^2
rownames(dat) <- sub_annot$pos
colnames(dat) <- sub_annot$pos
par(mar=c(8.1, 4.1, 4.1, 2.1), mgp=c(3, 1, 0), las=0)
phic = plotHic(dat, sub_annot$chr, as.integer(rownames(dat)[1]), as.integer(rownames(dat)[nrow(dat)]),
max_y, palette = function(x) colorRampPalette(c("aliceblue", "darkblue"))(x),
flip = FALSE)
#arrows(x0 = start, y0 = -0.1, x1 = end, y1 = -0.1, code = 0, xpd = T)
addlegend(phic[[1]], palette=phic[[2]], title="", side="right", bottominset=0.4, topinset=0,
xoffset=0.025, labelside="left", width=0.025, title.offset=0.07)
# labelgenome(sub_annot$chr, as.integer(rownames(dat)[1]), as.integer(rownames(dat)[nrow(dat)]),
#             side=1, scipen=20, n=0, scale="Mb", edgeblankfraction=0.30, line=.18, chromline=.5, scaleline=0.5)
#
start = sub_annot$pos[1]
end = sub_annot$pos[nrow(dat)]
jump = (end-start)/nrow(dat)
axis(side = 1, at = seq(start+jump/2, end-jump/2, jump), labels = rep('', nrow(dat)), srt = 90)
col_vec = rep('black', times = nrow(dat))
if(!is.null(probe2exclude))
{
col_vec[rownames(sub_annot) %in% probe2exclude] = 'magenta4'
}
col_vec[rownames(sub_annot) == CpG] = 'red3'
text(x = seq(start+jump/2, end-jump/2, jump), y = rep(-1, nrow(dat)), xpd = T, labels = rownames(sub_annot),
srt = 90, cex = 0.6, col = col_vec)
#axis(side = 1, at = seq(start+jump, end-jump+1, jump), labels = rep('', nrow(dat)-1), srt = 90, pos = c(-1.7), col = 'cornsilk4')
deltaD = sapply(1:(nrow(dat)-1), function(x) sub_annot$pos[x+1]-sub_annot$pos[x])
text(x = seq(start+jump, end-jump+1, jump), y = rep(-0.2, nrow(dat)), xpd = T, labels = deltaD,
srt = 0, cex = 0.6, col = 'cornsilk4')
par(mar=c(5.1, 4.1, 4.1, 2.1), mgp=c(3, 1, 0), las=0)
text(x = end, y = -0.2, labels = expression(paste(Delta, delta)), xpd = T)
text(x = (start + end)/2, y = -2.1, labels = sub_annot$chr, xpd = T)
cor_vec = sapply(1:nrow(beta_mat), function(x) cor(beta_mat[x, seq(1, ncol(beta_mat), 2)], beta_mat[x, seq(2, ncol(beta_mat), 2)],
method = "pearson")^2)
names(cor_vec) = rownames(beta_mat)
return(rownames(beta_mat))
}
# meQTL
UM_plot(M = M_U$M, U = M_U$U, CpG = "cg14911689", sex = NULL)
annotation["cg14911689", c("chr", "pos", "UCSC_RefGene_Name")] # chr12    739980    NINJ2
annotation <- annotation[order(annotation$chr, annotation$pos),]
pos <- which(rownames(annotation) == "cg14911689")
UM_plot(M = M_U$M, U = M_U$U, CpG = rownames(annotation)[pos-1], sex = NULL)
UM_plot(M = M_U$M, U = M_U$U, CpG = rownames(annotation)[pos+1], sex = NULL)
res = Visualize_cometh(annotation = annotation, CpG = 'cg14911689', distance = 1000,
L_bound = 3, R_bound = 2, beta_mat = beta_value,
cgHeightLabel = -1, deltaposHeightLabel = -0.4, chrHeightLabel = -2,
max_y = 5)
res = Visualize_cometh(annotation = annotation, CpG = 'cg14911689', distance = 1000,
L_bound = 3, R_bound = 2, beta_mat = beta_value, max_y = 5)
# meQTL
UM_plot(M = M_U$M, U = M_U$U, CpG = "cg14911689", sex = NULL)
# meQTL
UM_plot(M = M_U$M, U = M_U$U, CpG = "cg14911689", sex = NULL)
UM_plot(M = M_U$M, U = M_U$U, CpG = rownames(annotation)[pos-1], sex = NULL)
UM_plot(M = M_U$M, U = M_U$U, CpG = rownames(annotation)[pos+1], sex = NULL)
res = Visualize_cometh(annotation = annotation, CpG = 'cg14911689', distance = 1000,
L_bound = 3, R_bound = 2, beta_mat = beta_value, max_y = 5)
UM_plot(M = M_U$M, U = M_U$U, CpG = "cg11495604", sex = NULL)
res = Visualize_cometh(annotation = annotation, CpG = 'cg11495604', distance = 1000,
L_bound = 0, R_bound = 2, beta_mat = beta_value,
cgHeightLabel = -1, deltaposHeightLabel = -0.4, chrHeightLabel = -2,
max_y = 5)
res = Visualize_cometh(annotation = annotation, CpG = 'cg11495604', distance = 1000,
L_bound = 0, R_bound = 2, beta_mat = beta_value, max_y = 5)
UM_plot(M = M_U$M, U = M_U$U, CpG = "cg11495604", sex = NULL)
res = Visualize_cometh(annotation = annotation, CpG = 'cg11495604', distance = 1000,
L_bound = 0, R_bound = 2, beta_mat = beta_value, max_y = 5)
# HLA locus
res = Visualize_cometh(annotation = annotation, CpG = 'cg00211215', distance = 200,
L_bound = 3, R_bound = 0, beta_mat = beta_value, max_y = 5)
annotation["cg00211215", c("chr", "pos", "UCSC_RefGene_Name")] # chr6  32552246   HLA-DRB1
